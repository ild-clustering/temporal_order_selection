# functions used for clustering ILDs with LO method
library(aricode)
library(dplyr)
library(MASS)
library(ggplot2)
library(lattice)
library(caret)
library(MixSim)
library(sandwich)
library(urca)
library(lmtest)
library(vars)
library(mclust)
library(svMisc)
library(iterators)
library(foreach)
library(doParallel)
library(NbClust)
library(portes)
library(parallel)
library(portes)

# LO method--fitting VAR(1) model
cluster.var1.both=function(data,phi,randomstart,nob,k,p,repet,ncluster,percent){
  # data ILDs in each dataset
  # phi true AR and CR coefficients
  # randomstart: number of start points
  # nob: sample size
  # k: number of Intensive longtidinal variables
  # p: temporal order in fitting model
  # repet: number of replicates within each condition
  # ncluster: number of cluster
  # percent: relative size of clusters
  recovery=c() # accuracy proportion of membership correctly estimated by gmm
  ari=c() # ARI by gmm
  recovery.k=c() # accuracy proportion of membership correctly estimated by kmeans
  ari.k=c() # ari by kmeans
  #overlap=c() # overlap between any two clusters
  member.k=c() # specific membership for each individual based on solution by GMM
  member.g=c() # specific membership for each individual based on solution by kmeans
  
  ar=rep(NA,randomstart)
  acc=rep(NA,randomstart)
  ar.k=rep(NA,randomstart)
  acc.k=rep(NA,randomstart)
  a=Sys.time()
  
  for (time in 1:repet){
# get all coefficients within each dataset
    num.l=(nob)*(time-1)+1 
    num.h=(nob)*time
    coef_over=data[(num.l:num.h),]
    nu.l=ncluster*(time-1)+1
    nu.h=ncluster*time
    phi.t=phi[(nu.l:nu.h),] # get true phi matrix for corresponding dataset
    ### clustering

    phi.ind=coef_over
    phi.ind[,'mem.t']=as.factor(phi.ind[,'mem.t'])
    model_per_pers=coef_over[,-17]
    #### GMM   
    cl2 <- makeCluster(5)
    registerDoParallel(cl2)
    clusterEvalQ(cl2, library(mclust))
    clusterExport(cl2,c('model_per_pers'))
    parallel.function=function(nclust){
      # run GMM test number of cluster from 1-5
      #m=tryCatch(Mclust(model_per_pers, G=nclust),error=function(e){return(NA)})
      # start points used by using hierarchical clustering method
      m=tryCatch(Mclust(model_per_pers, G=nclust,initialization = list(hcPairs = hcrandomPairs(model_per_pers))),error=function(e){return(NA)})
      return(m)
    }
    
    outer <- function(nclust, cores, functiona){
      require(parallel)
      mclapply(1:cores, functiona)
    }
    
    mod=do.call(rbind,parLapply(cl2,1:randomstart,outer,5,parallel.function))
    
    stopCluster(cl2)
    closeAllConnections()randomPairs
    
    
    cl4 <- makeCluster(5)
    registerDoParallel(cl4)
    clusterEvalQ(cl4, library(mclust))
    clusterExport(cl4,c('model_per_pers'))
    #clusterEvalQ(cl3, library(NbClust))
   # random start point
    mod.smart=foreach(i=1:5) %dopar% {
      
      m.s=tryCatch(Mclust(model_per_pers, G=i),error=function(e){return(NA)})
      return(m.s)}
    stopCluster(cl4)
    closeAllConnections()
    
    
    mod=rbind(mod,mod.smart) # start points: generated by random for mod and generated by hierarchical partition for mod.smart
    
    # used bic select the best number of cluster and covariate structure
    bic=matrix(NA,nrow=(randomstart+1),ncol=5)
    for(run in 1:(randomstart+1)){
      for (nclust in 1:5){
        bic[run,nclust]=mod[run,nclust][[1]]$bic}
      member=mod[run,which(bic[run,]==max(bic[run,]))][[1]]$classification
      
      ar[run]=adjustedRandIndex(member,phi.ind[,17]) # ARI calculation
      
      acc[run]=1-classError(member,phi.ind[,17])$errorRate # accuracy
    }
    
    
    
    # find the solution which yielded the highest value in bic and get membership
    br=which(ar==max(ar))[1]# find the max value within 10 random starts+hierachical starts
    mem.g=mod[br,which(bic[br,]==max(bic[br,]))][[1]]$classification # membership generated by gmm
    num_cluster.g=length(unique(mem.g))
    phi.ind=cbind(phi.ind,mem.g)
    member.g=rbind(member.g,mem.g)
    
    
    recovery=c(recovery,max(acc))
    ari=c(ari,max(ar))
    
    
    
    ##### k-means
    
    cl3 <- makeCluster(5)
    registerDoParallel(cl3)
    clusterEvalQ(cl3, library(cluster))
    clusterEvalQ(cl3, library(factoextra))
    #clusterEvalQ(cl3, library(NbClust))
    clusterExport(cl3,c('model_per_pers'))
    
    
  
    mod.k=foreach(1:randomstart) %dopar% {
      # using gap method to find the best number of clusters
      a=clusGap(model_per_pers, FUN = kmeans, K.max = 5, B = 500)  
      op.n=which(a$Tab[,3]==max(a$Tab[,3]))
      m=kmeans(model_per_pers,op.n,nstart=500)
      return(m)}
    stopCluster(cl3)
    closeAllConnections()
    
    # use the start point generated by hierarchical clustering 
    hc_dist=function(x) dist(x, method = 'euclidean')
    hcl <- function(x, k) list(cluster=cutree(hclust(hc_dist(x), method = "average"),k=k))
    a=clusGap(model_per_pers, FUN = hcl, K.max =5, B = 500)  
    op.n=which(a$Tab[,3]==max(a$Tab[,3]))  
    
    h=hclust(dist(model_per_pers, method = 'euclidean'),method = 'average')
    member=cutree(h, k =  op.n)
    ini=c()
    for(c in 1: op.n){
      mean=colMeans(model_per_pers[member==c,])
      ini=rbind(ini,mean)
    }
    m.k.smart=kmeans(model_per_pers,centers=ini)
    
    
    
    mod.k=list(mod.k,mod.k.smart) # start points: generated by random for mod and generated by hierarchical partition for mod.smart
    
  
    print(Sys.time()-a)
    
    for(run in 1:(randomstart+1)){
      
      member=mod.k[[run]]$cluster
      
      ar.k[run]=adjustedRandIndex(member,phi.ind[,17])
      
      acc.k[run]=1-classError(member,phi.ind[,17])$errorRate
    } 
    br=which(ar.k==max(ar.k))[1] # find the max value within 10 random starts
    mem.k=mod.k[[br]]$cluster
    member.k=rbind(member.k,mem.k)
    phi.ind=cbind(phi.ind,mem.k)
    recovery.k=c(recovery.k,max(acc.k))
    ari.k=c(ari.k,max(ar.k))
    num_cluster.k=length(unique(mem.k))
   
  membership=cbind(t(member.g),t(member.k)) 
  result=rbind(recovery,ari)
  result=rbind(result,recovery.k)
  result=rbind(result,ari.k)
  }
  
  
  result=list(result,membership)
  return(result)}